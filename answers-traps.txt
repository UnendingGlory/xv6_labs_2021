int g(int x) {
   0:	1141                	addi	sp,sp,-16 # sp-16->sp
   2:	e422                	sd	s0,8(sp) # s0->sp+8
   4:	0800                	addi	s0,sp,16 # sp+16->s0
  return x+3;
}
   6:	250d                	addiw	a0,a0,3
   8:	6422                	ld	s0,8(sp) # sp+8->s0
   a:	0141                	addi	sp,sp,16
   c:	8082                	ret

000000000000000e <f>:

int f(int x) {
   e:	1141                	addi	sp,sp,-16
  10:	e422                	sd	s0,8(sp)
  12:	0800                	addi	s0,sp,16
  return g(x);
}
  14:	250d                	addiw	a0,a0,3
  16:	6422                	ld	s0,8(sp)
  18:	0141                	addi	sp,sp,16
  1a:	8082                	ret

000000000000001c <main>:

void main(void) {
  1c:	1141                	addi	sp,sp,-16
  1e:	e406                	sd	ra,8(sp)
  20:	e022                	sd	s0,0(sp)
  22:	0800                	addi	s0,sp,16
  printf("%d %d\n", f(8)+1, 13);
  24:	4635                	li	a2,13
  26:	45b1                	li	a1,12
  28:	00000517          	auipc	a0,0x0
  2c:	7a050513          	addi	a0,a0,1952 # 7c8 <malloc+0xe8>
  30:	00000097          	auipc	ra,0x0 # pc+0->ra
  34:	5f8080e7          	jalr	1528(ra) # 628 <printf>
  exit(0);
  38:	4501                	li	a0,0
  3a:	00000097          	auipc	ra,0x0  # pc+0->ra
  3e:	274080e7          	jalr	628(ra) # 2ae <exit>
......

1. Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?
  a0, a1, a2-a7 contains arguments to functions.
  a2 holds 13.

2. Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)
  No assembly code for f and g, compiler has inlined them.

3. At what address is the function printf located?
  Function printf jump the the address:
    1528 + (ra) = 1528 + (pc)
  = 1528 + 0x30 = 1528 + 48 = 1576
  = 1536 + 32 + 8
  = 6*16^2 + 2*16 + 8
  = 0x628
  So function printf is located at 0x628.

4. What value is in the register ra just after the jalr to printf in main?
  'jalr 1528(ra)' means that jump to 1528+(ra) = 0x628
  and save the return address to (pc) + 4 to the ra register
  so ra = (pc) + 4 = 0x34 + 4 = 0x38

5. Run the following code.   What is the output?

	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);

  The output is "HE110 World".
  57616D = E110H
  64 -> d, 6c -> l, 72 -> r
  If RISCV is big-endian, i needs to be 0x726c6400.
  Because i is stored in the memory.
  But no need to change 57616.
  In the beginning I thought it would be a immediate number in the assembly code.
  But actually 57616 doesn't appear.
  So It may be optimized by the compiler.

6. In the following code, what is going to be printed after 'y='? 
   (note: the answer is not a specific value.) Why does this happen?

	printf("x=%d y=%d", 3);
  
  assembly code:
  24:	458d                	li	a1,3
  26:	00000517          	auipc	a0,0x0
  2a:	7b250513          	addi	a0,a0,1970 # 7d8 <malloc+0xe6>
  2e:	00000097          	auipc	ra,0x0
  32:	60c080e7          	jalr	1548(ra) # 63a <printf>

  3->a1, a2 stored a number before this printf.
  So 'y=' print the number in the a2 register.
